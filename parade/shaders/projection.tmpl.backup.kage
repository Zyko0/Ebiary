//kage:unit pixels

package main

func toUV(p vec3) vec2 {
	return floor(p.xy + imageSrc0Size()/2 + imageSrc0Origin())
}

func phong(lightDir, normal, clr vec3) vec3 {
	// ambient
	ambient := clr * 0.25

	// diffuse
	dotLN := clamp(dot(lightDir, normal), 0., 1.)
	diffuse := clr * dotLN

	// specular
	halfwayDir := normalize(lightDir + normal)
	specular := vec3(0.25) * pow(max(dot(normal, halfwayDir), 0.), 64.)

	return ambient + diffuse + specular
}

func sdScene(p vec3, depthFactor float) float {
	//return length(p-vec3(0, 0, 50)) - 50
	q := abs(p) - vec3(imageSrc0Size()/2, depthFactor)
	_ = q
	if q.x <= 0 && q.y <= 0 {
		clr := imageSrc0UnsafeAt(toUV(p))
		/*if clr.a <= 0.9 {
			return 1
		}*/
		return (1-clr.x)*depthFactor - p.z
	}
	return 1
}

func normalScene(p vec3, depthFactor float) float {
	uv := p.xy + imageSrc0Size()/2 + imageSrc0Origin()
	clr := imageSrc0At(uv)
	return (1-clr.x+(1-clr.a))*depthFactor - p.z
}

func rayMarch(ro, rd vec3, depthFactor, start, end float) (vec3, vec3) {
	const (
		MaxSteps    = 512. * 4
		InitialMult = 16.
	)

	p := ro
	ri := 1. / rd
	rs := sign(rd)
	mm := vec3(0)
	dis := (p - ro + 0.5 + rs*0.5) * ri
	mult := 1.//InitialMult
	for i := 0; i < MaxSteps; i++ {
		d := sdScene(p /*-vec3(0, 0, start)*/, depthFactor)
		if d < 0 {
			return p, -mm * rs
			mini := (p - ro + 0.5 - 0.5*rs) * ri
			t := max(mini.x, max(mini.y, mini.z))
			_ = t
		}
		//oldxy := floor(p.xy)
		//for j := 0; j < 256; j++ {
		mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy)
		dis += (mm * rs * ri) * mult
		p += (mm * rs) * mult
		if p.z > end {
			break
		}
		/*fp := floor(p)
			if (oldxy.x != fp.x || oldxy.y != fp.y) {

				break
			}
		}*/

		//d = min(d, 1) // TODO: make 1 parametric as a quality setting
	}

	return vec3(9999), vec3(0) //depth
}

func calcNormal(p vec3, depthFactor float) vec3 {
	_, size := imageDstRegionOnTexture()
	_ = size
	// factor := 2 / size.y *1500//0.0005
	factor := 1. //imageSrc0Size().xy// / size //0.5 //0.5 //1500. / size
	e := vec2(1., -1.) * factor
	return -normalize(sdScene(p+e.xyy, depthFactor)*e.xyy +
		sdScene(p+e.yyx, depthFactor)*e.yyx +
		sdScene(p+e.yxy, depthFactor)*e.yxy +
		sdScene(p+e.xxx, depthFactor)*e.xxx,
	)
}

/*func calcNormal(p vec3, depthFactor float) vec3 {
	e := 1.
	hx1 := sdScene(vec3(p.x-e, p.y, 0.0), depthFactor)
	hx2 := sdScene(vec3(p.x+e, p.y, 0.0), depthFactor)
	pu := normalize(vec3(e, 0.0, hx2-hx1))

	hy1 := sdScene(vec3(p.x, p.y, 0.0), depthFactor)
	hy2 := sdScene(vec3(p.x, p.y+e, 0.0), depthFactor)
	pv := normalize(vec3(0.0, e, hy2-hy1))

	return cross(pu, pv)
}*/

var (
	Normal   float
	Specular float
)

var (
	CameraPVMatrixInv mat4
	LightPosition     vec3
)

func Fragment(dst vec4, src vec2, color vec4) vec4 {
	const pi = 3.1415

	startingDepth := color.r
	depthFactor := color.g * 10 //* 0.125
	maxDepth := startingDepth + depthFactor
	_, _ = startingDepth, maxDepth
	//return vec4(1, 0, 0, 1)
	/*halfsize := imageSrc0Size() / 2
	uv := src - imageSrc0Origin() - halfsize
	near4 := CameraPVMatrixInv * normalize(vec4(uv, -1, 1))
	far4 := CameraPVMatrixInv * normalize(vec4(uv, 1, 1))
	far3 := far4.xyz / far4.w
	// Ray calculation
	ro := near4.xyz / near4.w
	//ro.z += startingDepth
	//ro += fract(Position)
	rd := normalize(far3 - ro)*/
	//origin, size := imageSrc0Origin(), imageSrc0Size()
	origin, size := imageDstRegionOnTexture()
	halfsize := size / 2
	uv := dst.xy - origin - halfsize //src - imageSrc0Origin() - halfsize //(src-imageSrc0Origin())/imageSrc0Size()*2 - 1

	ro := vec3(uv.x, uv.y, startingDepth)
	//ro.z += startingDepth
	//rd := normalize(vec3(uv /*(imageSrc0Size()/2)*/, depthFactor)) //max(halfsize.x, halfsize.y)))
	//rd := normalize(vec3(normalize(uv), 1)) //max(halfsize.x, halfsize.y)))
	rd := normalize(vec3(uv/(halfsize*2), 1))
	//ro.z += startingDepth
	//ro += rd * startingDepth
	// TODO: ^ investigate if normalization should happen before adding depth offset

	/*ro := vec3(uv.x, uv.y, -HeightFactor)
	rd := normalize(vec3(uv*path(), 1.))*/
	p, normal := rayMarch(ro, rd, depthFactor, startingDepth, maxDepth)
	//p := ro + rd*d
	//if d > maxDepth {
	if p.z > maxDepth {
		discard()
		return
	}
	//return vec4(1., 0, 0, 1)

	//p := ro + rd*d
	// TODO: maybe p += starting depth here??
	//return vec4(normalize(p), 1.)
	clr := imageSrc0UnsafeAt(p.xy + /* sign(rd.xy)*/ +halfsize + imageSrc0Origin()) //toUV(p))
	/*if tclr := imageSrc0At(uv + vec2(1, 0)); tclr.a > clr.a {
		clr = tclr
	}
	if tclr := imageSrc0At(uv + vec2(0, 1)); tclr.a > clr.a {
		clr = tclr
	}
	if tclr := imageSrc0At(uv + vec2(-1, 0)); tclr.a > clr.a {
		clr = tclr
	}
	if tclr := imageSrc0At(uv + vec2(0, -1)); tclr.a > clr.a {
		clr = tclr
	}*/
	/*if clr.a < 0.1 {
		discard()
		return
	}*/
	normal *= -1
	normal = calcNormal(p, depthFactor)
	/*normal = normalize(
		fwidth(p),//vec3(dfdy(p.x), dfdx(p.y), dfdx(p.z)),
	)*/
	//return vec4((normal+1)/2, 1)
	//return vec4(clr.rgb, 1)
	lpos := vec3(0, 0, -200)
	ldir := normalize(p - lpos)
	clr.rgb = phong(ldir, normal, clr.rgb)

	return vec4(clr.rgb, 1.) * clr.a
}
