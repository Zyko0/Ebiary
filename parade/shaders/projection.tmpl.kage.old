//kage:unit pixels

package main

// Texture data fetching

func fetchDepth(uv vec2) vec4 {
	//p := uv + CameraPosition.xy
	//origin := imageSrc0Origin()
	//_ = origin
	//p = abs(mod(p, LayerSize+origin))
	return imageSrc0UnsafeAt(uv + CameraPosition.xy)
}

func fetchColor(uv vec2) vec4 {
	p := uv + CameraPosition.xy
	origin := imageSrc0Origin()
	_ = origin
	//p = abs(mod(p, LayerSize+origin))
	return imageSrc1UnsafeAt(p)
}

func toUV(p vec3) vec2 {
	return p.xy + ScreenSize/2 + imageSrc0Origin()
}

// Texture mapping

// "p" point apply texture to
// "n" normal at "p"
// "k" controls the sharpness of the blending in the
// transitions areas.
func boxmapColor(p, n vec3, k, df float) vec4 {
	// TODO: unclear atm
	pxy := p.xy
	_ = pxy
	p.xy += CameraPosition.xy + LayerSize/2
	p.z = mod(abs(p.z), df)
	//return vec4(0)
	origin := imageSrc0Origin()
	if p.y < 128 {
		//return vec4(0,1,0,1)
	}
	/*x := imageSrc1UnsafeAt(p.zy + vec2(CameraPosition.x, 0) + origin)
	y := imageSrc1UnsafeAt(p.xz + vec2(0, CameraPosition.y) + origin)
	z := imageSrc1UnsafeAt(p.xy + origin)*/
	sn := sign(n)
	x := imageSrc1UnsafeAt(vec2((p.x+df*sn.x)-p.z*sn.x, p.y) + vec2(CameraPosition.x, 0) + origin)
	y := imageSrc1UnsafeAt(vec2(p.x, (p.y+df*sn.y)-p.z*sn.y) + vec2(0, CameraPosition.y) + origin)
	z := imageSrc1UnsafeAt(p.xy + origin)
	//return y

	// Blend
	m := pow(abs(n), vec3(k))
	return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z)
}

// Light

func phong(lightDir, normal, clr vec3) vec3 {
	// ambient
	ambient := clr * 0.25

	// diffuse
	dotLN := clamp(dot(lightDir, normal), 0., 1.)
	diffuse := clr * dotLN

	// specular
	halfwayDir := normalize(lightDir + normal)
	specular := vec3(0.25) * pow(max(dot(normal, halfwayDir), 0.), 64.)

	return ambient + diffuse + specular
}

func sdScene(p, rd vec3, depthFactor float) float {
	//return length(p-vec3(0, 0, 50)) - 50
	q := abs(p.xy) - LayerSize/2
	_ = q
	if q.x <= 0 && q.y <= 0 {
		/*if clr.a <= 0.9 {
			return 1
		}*/
		data := fetchDepth(toUV(p))
		return (1-data.r*data.a)*depthFactor - p.z
	}
	return 1
}

func parallax(uv vec2, rd vec3, depthFactor float) (vec2, float, bool) {
	// number of depth layers
	//rd /= rd.z
	testrd := max(length(rd.xy), 0.15)
	//testrd = clamp(0, 1, testrd)
	numLayers := mix(depthFactor/64, depthFactor, max(dot(vec3(0, 0, 0.25), rd), 0))
	numLayers = mix(1, depthFactor, testrd)
	//rd /= rd.z
	//numLayers = depthFactor/2 // TODO: debug
	//numLayers = depthFactor
	//numLayers /= 4
	//numLayers = 128 // TODO:
	// calculate the size of each layer
	layerDepth := 1.0 / numLayers
	// the amount to shift the texture coordinates per layer (from vector P)
	p := rd.xyz * depthFactor
	deltap := p / numLayers

	data := fetchDepth(uv)
	currentDepth := data.r * data.a
	//return uv, currentDepth, true
	currentLayerDepth := 1. //0.2
	for i := 0; i < 1024; i++ {
		/*if currentLayerDepth < 0. {
			return vec2(0), 0, false
		}*/
		if currentLayerDepth < currentDepth {
			break
		}
		uv -= deltap.xy
		data = fetchDepth(uv)
		currentDepth = data.r * data.a
		currentLayerDepth -= layerDepth
	}

	// get texture coordinates before collision (reverse operations)
	/*prevuv := cuv + deltap.xy

	// get depth after and before collision for linear interpolation
	afterDepth := 1 - (currentDepth - layerDepth)
	beforeDepth := 1 - fetchDepth(prevuv).r + layerDepth + currentDepth

	// interpolation of texture coordinates
	weight := afterDepth / (afterDepth - beforeDepth)
	_ = weight
	//weight = afterDepth / (afterDepth + beforeDepth)
	cuv = prevuv*weight + cuv*(1.0-weight)*/
	//cuv = mix(prevuv, cuv, weight)
	//currentDepth = 1-weight
	//cuv += vec2(-250,500)
	//currentDepth = 0//beforeDepth + currentDepth*weight

	return uv, currentDepth - currentLayerDepth, currentLayerDepth > 0 //true
	//currentDepth -= weight*layerDepth
	//currentLayerDepth -= layerDepth*weight
}

func calcNormal(p, rd vec3, depthFactor float) vec3 {
	factor := 1. //imageSrc0Size().xy// / size //0.5 //0.5 //1500. / size
	e := vec2(1., -1.) * factor
	n := -normalize(sdScene(p+e.xyy, rd, depthFactor)*e.xyy +
		sdScene(p+e.yyx, rd, depthFactor)*e.yyx +
		sdScene(p+e.yxy, rd, depthFactor)*e.yxy +
		sdScene(p+e.xxx, rd, depthFactor)*e.xxx,
	)
	// TODO: attempt hack for very pixelated edges
	/*if length(n-fwidth(n)) > 1 {
		e *= 2
		return -normalize(sdScene(p+e.xyy, rd, depthFactor)*e.xyy +
			sdScene(p+e.yyx, rd, depthFactor)*e.yyx +
			sdScene(p+e.yxy, rd, depthFactor)*e.yxy +
			sdScene(p+e.xxx, rd, depthFactor)*e.xxx,
		)
		//return vec3(0)
	}*/

	return n
}

// https://iquilezles.org/articles/boxfunctions
// License MIT: https://www.shadertoy.com/view/ld23DV
func iBox(ro, rd, bb vec3) vec2 { //vec4 {
	m := 1. / rd
	n := m * ro
	k := abs(m) * bb
	t1 := -n - k
	t2 := -n + k

	tN := max(max(t1.x, t1.y), t1.z)
	tF := min(min(t2.x, t2.y), t2.z)

	if tN > tF || tF < 0 {
		return vec2(-1) // return vec4(-1)
	}

	return vec2(tN, tF)
	/*res := vec4(tN, step(tN, t1))
	res.yzw = (vec4(-sign(rd)*res.yzw, 0)).xyz

	return res*/
}

/*func softShadow(ro, rd vec3, mint, tmax float) float {
	const (
		MaxSteps = 16.
		Precision = 0.001
	)

	res := 1.
	t := mint
	for i := 0.; i < MaxSteps; i++ {
		h := sdScene(ro + rd * t)[0].x
		res = min(res, 8.*h/t)
		t += clamp(h, 0.02, 0.10)
		if h < Precision || t > tmax {
			break
		}
	}

	return clamp(res, 0., 1.)
}*/

var (
	Normal   float
	Specular float
)

var (
	ScreenSize vec2
	LayerSize  vec2
	ZDir       float
	BoxMapping float
)

var (
	CameraPVMatrixInv mat4
	CameraPosition    vec3
	LightPosition     vec3
)

func lookAt(eye, tar vec3, r float) mat3 {
	cw := normalize(tar - eye)     // camera w
	cp := vec3(sin(r), cos(r), 0.) // camera up
	cu := normalize(cross(cw, cp)) // camera u
	cv := normalize(cross(cu, cw)) // camera v
	return mat3(cu, cv, cw)
}

func Fragment(dst vec4, src vec2, color vec4) vec4 {
	const pi = 3.1415

	// Vertex options
	startingDepth := color.r
	depthFactor := color.g
	// Camera setup
	origin := imageSrc0Origin()
	//size := imageSrc0Size()
	halfsize := ScreenSize / 2
	uv := src.xy - origin - halfsize
	uv = -uv // TODO: idk why

	ro := vec3(uv.x, uv.y, -startingDepth)

	rd := normalize(
		vec3(uv, max(halfsize.x, halfsize.y)),
	)
	/*rd := normalize(
		vec3(uv/halfsize, 1.),
	)*/
	//rd = normalize(vec3(sign(uv), 1))//rd*normalize(vec3(1, 1, 1)))

	/* Camera attempt */
	//return vec4(1)
	near4 := CameraPVMatrixInv * normalize(vec4(uv/halfsize, 0, 1))
	far4 := CameraPVMatrixInv * normalize(vec4(uv/halfsize, 1, 1))
	far3 := far4.xyz / far4.w
	_, _ = near4, far3
	// Ray calculation
	rd = normalize(far3)
	//return vec4(1)
	//rd = normalize(vec3(1,1,0.7))
	rd /= rd.z

	/* End camera attempt */

	ibb := vec3(LayerSize/2, 0.) //0.01)
	// Discard if outside the projected box
	dib := iBox(ro-vec3(0, 0, ZDir*depthFactor), rd, ibb)
	if dib.x == -1 && dib.y == -1 {
		//return vec4(0, 1, 0, 1)
		discard()
		return
	}
	ro = ro + rd*dib.x
	//return vec4(1)

	tuv, d, ok := parallax(toUV(-ro), rd, depthFactor)
	_ = ok
	//if !ok || tuv.x > origin.x+LayerSize.x || tuv.x < origin.x || tuv.y > origin.y+LayerSize.y || tuv.y+CameraPosition.y < origin.y {
	if !ok || tuv.x+CameraPosition.x < origin.x ||
		tuv.y+CameraPosition.y < origin.y ||
		tuv.x+CameraPosition.x > origin.x+LayerSize.x ||
		tuv.y+CameraPosition.y > origin.y+LayerSize.y {
		//return vec4(0, 0, 1, 1)
		discard()
		return
	}

	p := vec3(tuv-imageSrc0Origin()-halfsize, -startingDepth+d*depthFactor)
	//return vec4(clr.rgb, 1.) * clr.a
	//p = vec3(uv.x, uv.y, 0) + rd*(d*depthFactor)
	normal := calcNormal(p, rd, depthFactor)

	var clr vec4
	if BoxMapping < 0.5 {
		clr = fetchColor(tuv)
	} else {
		clr = boxmapColor(p, normal, 1, 128/2) //TODO: need max depth
	}
	//clr = fetchColor(tuv)

	//return vec4((normal+1)/2, 1) // TODO: normal debug
	//clr.rgb = normalize(vec3(tuv-halfsize-imageSrc0Origin(), p.z)) // TODO: debug colors
	//return vec4(clr.rgb, 1)
	lpos := vec3(0, 0, -250)//-startingDepth-200)
	ldir := normalize(p - lpos)
	clr.rgb = phong(ldir, normal, clr.rgb)

	return vec4(clr.rgb, 1.) * clr.a
}
